{"version":3,"sources":["utils/moves.ts","utils/level.ts","utils/point.ts","utils/gen.ts","fe/manager.ts","fe/GameView.tsx","fe/App.tsx","script/index.ts","index.js"],"names":["Move","Moves","Object","keys","filter","k","isNaN","Number","map","MoveHistory","point","moves","classCallCheck","this","createClass","key","value","length","move","push","_this","last","m","concat","toConsumableArray","join","Level","width","height","start","win","blocks","loc","equals","some","b","x","y","moveHistory","current","next","clone","Left","Right","Up","Down","Error","isWinningPoint","isIllegalPoint","spawn","visited","queue","getNextMoves","counter","shift","applyMove","toString","apply","grid","_loop","row","_loop2","char","forEach","SolvableLevel","level","soln","PlayableLevel","solved","hero","addMove","newPoint","updatePoint","Point","other","exclude","excludeKeys","reduce","p","Math","floor","random","str","parts","split","parseFloat","Generator","blockPercent","minMoves","bound","randomWithin","n","arr","i","range","_","solution","solve","max","tries","levels","l","tryGenerateLevel","moveMap","ArrowLeft","ArrowRight","ArrowUp","ArrowDown","loadImage","url","img","Image","state","image","loaded","Promise","resolve","reject","onload","src","GameManager","canvasElm","ctx","currentLevel","sprites","ready","getContext","allSprites","values","all","s","then","window","addEventListener","e","code","undefined","handleMove","reset","draw","newLevel","moveHero","generateLevels","console","log","printMoves","_draw","asyncToGenerator","regenerator_default","a","mark","_callee","blockWidth","blockHeight","wrap","_context","prev","fillStyle","fillRect","font","fillText","abrupt","strokeStyle","beginPath","moveTo","lineTo","stroke","block","drawImage","stop","arguments","Canvas","styled","canvas","_templateObject","GameView","_React$Component","props","possibleConstructorReturn","getPrototypeOf","call","canvasRef","manager","React","createRef","inherits","react_default","createElement","ref","Component","Container","div","App_templateObject","script","testLevelGen","l1","print","l2","scripts","ReactDOM","render","GameView_GameView","document","getElementById"],"mappings":"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","file":"static/js/main.1a341b87.chunk.js","sourcesContent":["import { Point } from \"./point\";\n\nexport enum Move {\n  Up = 1,\n  Down,\n  Left,\n  Right,\n};\nexport const Moves = Object\n  .keys(Move)\n  .filter(k => isNaN(Number(k)))\n  .map(k => Move[k]);\n\nexport class MoveHistory {\n  point: Point;\n  moves: Array<Move>;\n\n  constructor(point: Point, moves: Array<Move>) {\n    this.point = point;\n    this.moves = moves;\n  }\n\n  last() {\n    return this.moves[this.moves.length - 1]\n  }\n  addMove(move: Move) {\n    this.moves.push(move);\n  }\n  updatePoint(point: Point) {\n    // todo point history?\n    this.point = point;\n  }\n\n  getNextMoves() {\n    const last = this.last();\n    return Moves\n      .filter(m => m !== last)\n      .map(m => new MoveHistory(\n        this.point,\n        [...this.moves, m]\n      ));\n  }\n\n  printMoves() {\n    return this.moves.map(k => Move[k]).join(', ');\n  }\n}\n","// https://repl.it/@mpaulweeks/ice\n\nimport { Move, MoveHistory } from './moves';\nimport { Point } from './point';\n\nexport class Level {\n  width: number;\n  height: number;\n  start: Point;\n  win: Point;\n  blocks: Array<Point>;\n\n  constructor(width: number, height: number, start: Point, win: Point, blocks: Array<Point>) {\n    this.width = width;\n    this.height = height;\n    this.start = start;\n    this.win = win;\n    this.blocks = blocks;\n  }\n\n  isWinningPoint(loc: Point) {\n    return this.win.equals(loc);\n  }\n  isIllegalPoint(loc: Point) {\n    const { blocks, width, height } = this;\n    const hitBlock = blocks.some(b => b.equals(loc));\n    return hitBlock || (\n      (loc.x < 0) ||\n      (loc.x >= width) ||\n      (loc.y < 0) ||\n      (loc.y >= height)\n    );\n  }\n  applyMove(moveHistory: MoveHistory): Point {\n    let move = moveHistory.moves[moveHistory.moves.length - 1];\n    let current = moveHistory.point;\n    while (true) {\n      const next = current.clone();\n\n      if (move === Move.Left) next.x--;\n      else if (move === Move.Right) next.x++;\n      else if (move === Move.Up) next.y--;\n      else if (move === Move.Down) next.y++;\n      else throw new Error(`unexpected move: ${move}`);\n\n      if (this.isWinningPoint(next)) {\n        return next;\n      }\n      if (this.isIllegalPoint(next)) {\n        return current;\n      }\n      current = next;\n    }\n  }\n  solve() {\n    const spawn = new MoveHistory(this.start, []);\n    const visited = {};\n    const queue = [...spawn.getNextMoves()];\n    let counter = 0;\n    while (counter < 8000 && queue.length) {\n      counter++;\n      let next = queue.shift() as MoveHistory;\n      next.point = this.applyMove(next);\n      if (this.isWinningPoint(next.point)) {\n        return next;\n      }\n      const key = next.point.toString();\n      if (!visited[key]) {\n        queue.push(...next.getNextMoves());\n        visited[key] = next;\n      }\n    }\n    return null;\n  }\n\n  print() {\n    const { width, height, start, win, blocks } = this;\n    const grid: Array<Array<string>> = [];\n    for (let y = 0; y < height; y++) {\n      const row: Array<string> = [];\n      for (let x = 0; x < width; x++) {\n        let char = '_';\n        if (win.x === x && win.y === y) {\n          char = 'W';\n        }\n        if (start.x === x && start.y === y) {\n          char = 'S';\n        }\n        blocks.forEach(b => {\n          if (b.x === x && b.y === y) {\n            char = '0';\n          }\n        });\n        row.push(char);\n      }\n      grid.push(row);\n    }\n    return grid.map(row => row.join('')).join('\\n');\n  }\n}\n\nexport class SolvableLevel {\n  level: Level;\n  soln: MoveHistory;\n  constructor(level: Level, soln: MoveHistory) {\n    this.level = level;\n    this.soln = soln;\n  }\n}\n\nexport class PlayableLevel {\n  level: Level;\n  soln: MoveHistory;\n  hero: MoveHistory;\n\n  constructor(solved: SolvableLevel) {\n    this.level = solved.level;\n    this.soln = solved.soln;\n    this.hero = new MoveHistory(this.level.start, []);\n  }\n\n  reset() {\n    this.hero = new MoveHistory(this.level.start, []);\n  }\n\n  moveHero(move: Move) {\n    const { level, hero } = this;\n    hero.addMove(move);\n    const newPoint = level.applyMove(hero);\n    hero.updatePoint(newPoint);\n  }\n}\n","\nexport class Point {\n  x: number;\n  y: number;\n\n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n  }\n  clone() {\n    return new Point(this.x, this.y);\n  }\n  toString() {\n    return `${this.x},${this.y}`;\n  }\n  equals(other: Point) {\n    return this.toString() === other.toString();\n  }\n\n  randomWithin(exclude: Array<Point>) {\n    let newPoint: (Point | undefined);\n    const excludeKeys = exclude.reduce((map, p) => {\n      map[p.toString()] = true;\n      return map;\n    }, {});\n    while (!newPoint || excludeKeys[newPoint.toString()]) {\n      newPoint = new Point(\n        Math.floor(Math.random() * this.x),\n        Math.floor(Math.random() * this.y)\n      );\n    }\n    return newPoint;\n  }\n  static fromString(str: string) {\n    const parts = str.split(',');\n    return new Point(parseFloat(parts[0]), parseFloat(parts[1]));\n  }\n};\n","import { Level, SolvableLevel } from \"./level\";\nimport { Point } from \"./point\";\n\nfunction range(n: number): Array<number> {\n  let arr: Array<number> = [];\n  for (let i = 0; i < n; i++) {\n    arr.push(i);\n  }\n  return arr;\n}\n\nexport class Generator {\n  width: number;\n  height: number;\n  blockPercent: number;\n  minMoves: number;\n\n  constructor(width: number, height: number, blockPercent: number, minMoves: number) {\n    this.width = width;\n    this.height = height;\n    this.blockPercent = blockPercent;\n    this.minMoves = minMoves;\n  }\n\n  tryGenerateLevel(): (SolvableLevel | null) {\n    const { width, height, blockPercent, minMoves } = this;\n    const bound = new Point(width, height);\n    const win = bound.randomWithin([]);\n    const start = bound.randomWithin([win]);\n    const blocks = range(width * height * blockPercent).map(_ => bound.randomWithin([win, start]));\n    const level = new Level(width, height, start, win, blocks);\n    const solution = level.solve();\n    return solution && solution.moves.length > minMoves ? new SolvableLevel(level, solution) : null;\n  }\n\n  generateLevels(max: number, tries: number): Array<SolvableLevel> {\n    const levels: Array<SolvableLevel> = [];\n    for (let i = 0; levels.length < max && i < tries; i++) {\n      const l = this.tryGenerateLevel();\n      if (l) {\n        levels.push(l);\n      }\n    }\n    return levels;\n  }\n}\n","import { Generator, Move, PlayableLevel } from \"../utils\";\n\nconst moveMap: { [code: string]: Move } = {\n  'ArrowLeft': Move.Left,\n  'ArrowRight': Move.Right,\n  'ArrowUp': Move.Up,\n  'ArrowDown': Move.Down,\n};\n\ninterface Sprite {\n  image: HTMLImageElement;\n  loaded: Promise<boolean>;\n}\n\ninterface Sprites {\n  hero: Sprite;\n};\n\nfunction loadImage(url: string) {\n  const img = new Image();\n  const state: Sprite = {\n    image: img,\n    loaded: new Promise((resolve, reject) => {\n      img.onload = () => resolve(true);\n    }),\n  };\n  img.src = url;\n  return state;\n}\n\nexport class GameManager {\n  canvasElm: HTMLCanvasElement;\n  ctx: CanvasRenderingContext2D;\n  currentLevel: (PlayableLevel | undefined);\n  sprites: Sprites;\n  ready: Promise<boolean>;\n\n  constructor(canvasElm: HTMLCanvasElement) {\n    this.canvasElm = canvasElm;\n    canvasElm.width = 800;\n    canvasElm.height = 600;\n    this.ctx = canvasElm.getContext('2d') as CanvasRenderingContext2D;\n\n    this.sprites = {\n      hero: loadImage('img/ice_blue.png'),\n    };\n    const allSprites = Object.values(this.sprites);\n    this.ready = Promise.all(allSprites.map(s => s.loaded)).then(() => true);\n\n    window.addEventListener('keydown', e => {\n      // console.log(e);\n      const move = moveMap[e.code] || undefined;\n      if (move) {\n        this.handleMove(move);\n      }\n      if (e.code === 'KeyR') {\n        this.currentLevel && this.currentLevel.reset();\n        this.draw();\n      }\n      if (e.code === 'KeyN') {\n        this.newLevel();\n      }\n    });\n  }\n\n  handleMove(move: Move) {\n    const { currentLevel } = this;\n    if (!currentLevel) {\n      return;\n    }\n    currentLevel.moveHero(move);\n    this.draw();\n  }\n  newLevel() {\n    const generator = new Generator(10, 8, Math.random() * 0.1 + 0.2, Math.random() * 10 + 5);\n    const newLevel = generator.generateLevels(1, 1000)[0];\n    if (newLevel) {\n      console.log('solution:', newLevel.soln.printMoves());\n    }\n    this.currentLevel = newLevel && new PlayableLevel(newLevel);\n    this.draw();\n  }\n\n  async draw() {\n    const { canvasElm, ctx, currentLevel, ready, sprites } = this;\n    const { width, height } = canvasElm;\n\n    await ready;\n\n    ctx.fillStyle = 'black';\n    ctx.fillRect(0, 0, width, height);\n\n    if (!currentLevel) {\n      ctx.font = '20px monospace';\n      ctx.fillStyle = 'white';\n      ctx.fillText('making level failed, try again', 100, 100);\n      return;\n    }\n\n    const blockWidth = width / currentLevel.level.width;\n    const blockHeight = height / currentLevel.level.height;\n\n    // grid\n    ctx.strokeStyle = 'white';\n    for (let y = 0; y < currentLevel.level.height; y++) {\n      ctx.beginPath();\n      ctx.moveTo(0, y * blockHeight);\n      ctx.lineTo(width, y * blockHeight);\n      ctx.stroke();\n    }\n    for (let x = 0; x < currentLevel.level.width; x++) {\n      ctx.beginPath();\n      ctx.moveTo(x * blockWidth, 0);\n      ctx.lineTo(x * blockWidth, height);\n      ctx.stroke();\n    }\n\n    ctx.fillStyle = 'grey';\n    ctx.fillRect(currentLevel.level.start.x * blockWidth, currentLevel.level.start.y * blockHeight, blockWidth, blockHeight);\n\n    ctx.fillStyle = 'lightgreen';\n    ctx.fillRect(currentLevel.level.win.x * blockWidth, currentLevel.level.win.y * blockHeight, blockWidth, blockHeight);\n\n    ctx.fillStyle = 'lightgrey';\n    currentLevel.level.blocks.forEach(block => {\n      ctx.fillRect(block.x * blockWidth, block.y * blockHeight, blockWidth, blockHeight);\n    });\n\n    ctx.drawImage(\n      sprites.hero.image,\n      currentLevel.hero.point.x * blockWidth + blockWidth * 0.2,\n      currentLevel.hero.point.y * blockHeight + blockHeight * 0.2,\n      blockWidth * 0.6,\n      blockHeight * 0.6\n    );\n  }\n}\n","import React from 'react';\nimport styled from 'styled-components';\nimport { GameManager } from './manager';\n\nconst Canvas = styled.canvas`\n  width: 800px;\n  height: 600px;\n`;\n\ninterface Props { }\n\nexport class GameView extends React.Component<Props> {\n  canvasRef: React.RefObject<HTMLCanvasElement>;\n  manager: (GameManager | undefined) = undefined;\n\n  constructor(props: Props) {\n    super(props);\n    this.canvasRef = React.createRef();\n  }\n\n  componentDidMount() {\n    const canvasElm = this.canvasRef.current;\n    if (canvasElm) {\n      this.manager = new GameManager(canvasElm);\n      this.manager.newLevel();\n    }\n  }\n\n  render() {\n    return (\n      <Canvas ref={this.canvasRef} >\n      </Canvas>\n    );\n  }\n}\n","import React from 'react';\nimport { GameView } from './GameView';\nimport styled from 'styled-components';\n\nconst Container = styled.div`\n  padding: 2rem;\n\n  display: flex;\n  flex-direction: column;\n  justify-content: flex-start;\n  align-items: center;\n  flex-wrap: nowrap;\n`;\n\nexport function App() {\n  return (\n    <Container>\n      <h1>\n        ice slide puzzle game\n      </h1>\n      <p>\n        use arrow keys to move, R to restart, and N to make new level\n      </p>\n      <GameView />\n    </Container>\n  );\n}\n","import { Generator, Level, Point } from '../utils';\n\nfunction testLevelGen() {\n  const l1 = new Level(\n    5, 5, new Point(1, 1), new Point(3, 3), [\n      new Point(2, 4),\n    ]\n  );\n  console.log(l1.print())\n  console.log(l1.solve())\n\n  const l2 = new Level(\n    5, 5, new Point(1, 1), new Point(3, 3), [\n      new Point(4, 0),\n    ]\n  );\n  console.log(l2.print())\n  console.log(l2.solve())\n\n  const gen = new Generator(5, 5, 0.1, 5);\n  const levels = gen.generateLevels(10, 1000);\n  levels.forEach(l => {\n    console.log(l.level.print())\n    console.log('Solution:', l.soln.printMoves())\n    console.log('\\n');\n  });\n};\n\nexport default {\n  testLevelGen,\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { App } from './fe/App';\nimport './fe/index.css';\nimport scripts from './script';\n\n// debug scripts via the browser console\nwindow.scripts = scripts;\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}